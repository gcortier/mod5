Dans ce projet, vous allez poser les bases dâ€™une architecture moderne en sÃ©parant le frontend et le backend, en dockerisant les composants, en dÃ©finissant une logique de calcul simple, et en prÃ©parant le projet pour une intÃ©gration continue. Ce template servira de socle aux futurs projets dÃ©ployÃ©s.
ReÌfeÌrentiels
CompÃ©tences transversales
CompeÌtences viseÌes
Ressources
docker compose
github action CI
Contexte du projet
FastIA souhaite mettre en place une architecture de base pour ses projets IA.


https://docs.google.com/document/d/1EgYEtMalAhMkZm5m78RHs62w6ngZxsqZOKuqMbj2E8c/edit?tab=t.0
https://docs.google.com/presentation/d/1-7_ypG-Lrn0YsNK9RMBZA9ZfzOvAGcZo4gua23jrVTQ/edit?slide=id.g33543ac44ba_0_119#slide=id.g33543ac44ba_0_119


Lâ€™objectif est dâ€™avoir un frontend utilisateur simple, une API FastAPI bien structurÃ©e, un environnement conteneurisÃ© avec Docker et une automatisation des tests via GitHub Actions.

Cette architecture servira de modÃ¨le reproductible pour tous les futurs projets de dÃ©ploiement.

L'Ã©quipe MLOps vous confie donc la mission de crÃ©er un template minimaliste, facilement extensible, conforme aux bonnes pratiques dâ€™ingÃ©nierie logicielle.

structurer le dÃ©pÃ´t de code et versionne le code.
prÃ©parer un script de dÃ©ploiement de lâ€™API (FastAPI).
Il connecte les diffÃ©rentes Ã©tapes de test, dÃ©ploiement, mise Ã  jour et suivi Ã  travers une chaÃ®ne CI/CD via GitHub Actions
Ce geste professionnel sâ€™inscrit dans une logique dâ€™amÃ©lioration continue, oÃ¹ les donnÃ©es Ã©volutives, les retours mÃ©tier et les performances du modÃ¨le sont pris en compte pour piloter les mises Ã  jour futures.

ModaliteÌs pÃ©dagogiques
Projet individuel. Les livrables doivent Ãªtre versionnÃ©s dans un dÃ©pÃ´t Git propre, organisÃ©, avec un fichier README clair. Les outils Ã  utiliser sont :

Streamlit pour le frontend
FastAPI + Pydantic pour lâ€™API
Docker & Docker Compose pour lâ€™environnement
Loguru pour les logs
pytest pour les tests backend
GitHub + GitHub Actions pour lâ€™intÃ©gration continue
Contraintes techniques spÃ©cifiques :

Le champ du frontend envoie un entier vers une API REST.
Lâ€™API retourne le carrÃ© de lâ€™entier aprÃ¨s validation du type.
Le calcul se fait dans un fichier dÃ©diÃ© modules/calcul.py.
Le backend contient un dossier tests/ avec un test de cette fonction.
Le Docker Compose ne doit lancer que le frontend et le backend.
Aucune base de donnÃ©es nâ€™est requise Ã  ce stade.
â€‹

Structure Ã  respecter

ğŸ“ frontend/ â””â”€â”€ app.py (Streamlit + Loguru) â””â”€â”€ Dockerfile ğŸ“ backend/ â””â”€â”€ main.py (FastAPI avec 3 routes) â””â”€â”€ modules/calcul.py â””â”€â”€ tests/test_calcul.py â””â”€â”€ Dockerfile ğŸ“„ docker-compose.yml

ModalitÃ©s d'Ã©valuation
Lâ€™API rÃ©pond bien aux 3 routes dÃ©finies (/, /health, /calcul)
Le frontend affiche une UI simple et fonctionnelle
Le calcul est correct et validÃ© via Pydantic
La structure du projet est propre et conforme
Le Docker Compose dÃ©marre sans erreur les deux services
Les logs sont lisibles et correctement intÃ©grÃ©s via Loguru
Les tests pytest fonctionnent et couvrent la fonction calcul()
Un fichier .github/workflows/test.yml valide lâ€™exÃ©cution des tests automatisÃ©s
Livrables
DÃ©pÃ´t Git avec :
- frontend/app.py + Dockerfile
- backend/main.py, modules/calcul.py, tests/test_calcul.py, Dockerfile
- docker-compose.yml
- .github/workflows/test.yml

README.md dÃ©crivant lâ€™architecture, les routes, les instructions de lancement
CritÃ¨res de performance
Le projet respecte les standards de dÃ©veloppement MLOps (modularitÃ©, logs, tests, CI/CD)
Lâ€™environnement Docker est isolÃ©, reproductible et bien configurÃ©
La logique mÃ©tier est dÃ©couplÃ©e, testable, rÃ©utilisable
Lâ€™intÃ©gration continue fonctionne dÃ¨s le push sur GitHub
Le code est clair, documentÃ©, et facilement maintenable